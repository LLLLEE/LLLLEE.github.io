<html>
<head>
	
	<title></title>
	<meta name="keywords" content="My Blog, Spider Bitch!" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
    <!--<link rel="stylesheet" href="/css/main.css">-->
	<link href="/css/main.css?v=2" rel="stylesheet" type="text/css" />
    <!--<link rel="stylesheet" href="/css/style.css">-->
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2"/>
    

</head>

<body>

<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><hr>
<h2 id="什么是建造者模式？"><a href="#什么是建造者模式？" class="headerlink" title="什么是建造者模式？"></a>什么是建造者模式？</h2><blockquote>
<p>建造者模式（Builder），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p><strong>要点：</strong><br>将一个复杂对象的构建与它的表示分离。另一种表述：建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。</p>
<p><strong>我的理解：</strong><br>我觉得所谓的「将一个复杂对象的构建与它的表示分离」，就是指通过使用Builder这个对象，来实现复杂对象非直接实例化。具体如下：「使用 Builder 的构造方法和Builder对象的各种set方法来构造复杂对象的一些部件（即为复杂对象的属性赋值）」和「使用 Builder 对象的 build ( ) 方法来实例化复杂对象」。</p>
<p><strong>区别：</strong><br>这里表达的「建造者模式」不同于书本上表达的。因为书本上的那种表达，是会出现 ConcreteBuilder 以及 Director 的。而这里说的「建造者模式」的核心则是「Builder」，这个 Builder ，它不是一个抽象类，而是一个静态内部类。</p>
<p><strong>我的想法：</strong><br>会出现上面说的「区别」，也许是我对「建造者模式」还不理解吧。我现在的想法呢，是觉得书本上那种「建造者模式」没什么用、无法理解，而后面那种呢，却能理解而且觉得很有用。</p>
<h2 id="我能理解且觉得有用的那种建造者模式"><a href="#我能理解且觉得有用的那种建造者模式" class="headerlink" title="我能理解且觉得有用的那种建造者模式"></a>我能理解且觉得有用的那种建造者模式</h2><p>首先，上代码：</p>
<pre>
public class Person2
{
    //用于接收builder中的字段
    private final String name;
    private final String id;
    private final String phoneNumber;
    private String address;
    private String dormitoryId;
    private String classId;
    private String email;
    private String weChatId;

    public static class Buidler{
        private final String name;
        private final String id;
        private final String phoneNumber;
        private String address;
        private String dormitoryId;
        private String classId;
        private String email;
        private String weChatId;

        //此处也是一个构造函数，用来实现必要字段必传的效果
        public Buidler(String name, String id, String phoneNumber)
        {
            this.name = name;
            this.id = id;
            this.phoneNumber = phoneNumber;
        }

        /**
         * 以下几个字段根据需要，可传可不传，可以把builder理解成一个容器，不断填充此容器，
         * 填充完以后,把此时的builder传到当前类的构造函数中
         */
        public Buidler setAddress(String address){
            this.address = address;
            return this;
        }

        public Buidler setDormitory(String dormitoryId){
            this.dormitoryId = dormitoryId;
            return this;
        }

        public Buidler setClassId(String classId){
            this.classId = classId;
            return this;
        }

        public Buidler setEmail(String email){
            this.email = email;
            return this;
        }

        public Buidler setWeChatId(String weChatId){
            this.weChatId = weChatId;
            return this;
        }

        public Person2 build(){
            return new Person2(this);
        }
    }

    //接收builder的值
    public Person2(Buidler buidler)
    {
        this.name = buidler.name;
        this.id = buidler.id;
        this.phoneNumber = buidler.phoneNumber;
        this.address = buidler.address;
        this.dormitoryId = buidler.dormitoryId;
        this.classId = buidler.classId;
        this.email = buidler.email;
        this.weChatId = buidler.weChatId;
    }

    public void print() {
        // TODO Auto-generated method stub
        StringBuffer sb = new StringBuffer();
        sb.append("姓名：" + name + "\n");
        sb.append("学号：" + id + "\n");
        sb.append("手机号码：" + phoneNumber+"\n");

        if(!isEmpty(address))
            sb.append("地址："+address+"\n");
        if(!isEmpty(dormitoryId))
            sb.append("宿舍号："+dormitoryId+"\n");
        if(!isEmpty(classId))
            sb.append("班级号："+classId+"\n");
        if(!isEmpty(email))
            sb.append("邮箱："+email+"\n");
        if(!isEmpty(weChatId))
            sb.append("微信号："+weChatId+"\n");

        System.out.println(sb.toString());
    }
}
</pre>

<p>以及测试代码：</p>
<pre>
public class BuilderTest{
    public static void main(String[] args) {
        Buidler buidler = new Buidler("zero", "31101037", "1866***2153");
        buidler.setClassId("311010");
        buidler.setDormitory("X9-107");
        Person2 person2 = buidler.build();
        person2.print();
        System.out.println("-----------------------分割线--------------------------");
        Person2 person = new Buidler("first", "31101001", "1709***9816").setAddress("淮安市清浦区枚乘路信息学院").setClassId("311010").build();
        person.print();
        System.out.println("-----------------------分割线--------------------------");
        new Buidler("ten", "31101010", "1327***3917").setEmail("596878238@qq.com").setClassId("311010").build().print();   
    }
}
</pre>

<blockquote>
<p>代码出处：<a href="http://blog.csdn.net/pangpang123654/article/details/52250775" target="_blank" rel="external">http://blog.csdn.net/pangpang123654/article/details/52250775</a></p>
</blockquote>
<p><strong>我的解读：</strong></p>
<p>Builder 的构造方法中的参数，是必须设置的属性。而其他的属性，则是可选项，可选可不选。因此，那些可选项具有 set 方法（并且这些 set 方法会返回 Builder 对象，以便可以把调用连接起来），需要哪个就调用哪个 set 方法去设置属性。</p>
<p>通过上面所说的，Builder 它构造了复杂对象的属性。然后通过 build( ) 方法，将 Builder 对象传到复杂对象的构造方法中，再依次将 Builder 对象的属性赋值给复杂对象的属性，如此来实例化复杂对象。</p>
<p>恩，就是这样。也许这种并不是建造者模式吧，而是构建器的使用吧。但是，它却是符合开头所说的「将一个复杂对象的构建与它的表示分离」。所以它到底是不是建造者模式？</p>
<p><strong>扩展：</strong></p>
<p>在 build ( ) 方法里，可以对属性值是否合法进行判断。若有不合法的，则抛出异常或作相应的处理。例如，判断属性手机号码是否为11位的数字。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>使用构建器 Builder 的话，那么复杂对象的属性是不能修改的，因为复杂对象所属的类是属于不可改变的类。</p>
<p>那么当我们想修改的时候怎么办？还是说只有确定不去修改复杂对象的属性的前提下我们才考虑用构建器实例化复杂对象？「 Effective Java 」里说了，那个复杂对象所属的类是不可变的。</p>
<h2 id="为什么要使用构建器？"><a href="#为什么要使用构建器？" class="headerlink" title="为什么要使用构建器？"></a>为什么要使用构建器？</h2><p>现在在我看来，是为了解决「复杂对象有很多属性，但是在实例化的时候仅有部分属性是必填的，另外一部分是选填的。因此如果使用构造函数来实例化复杂对象，则需要重载很多种构造函数。不仅如此，当需求变了，增加了一个属性或者删了一个属性，那么一部分构造函数需要作修改处理。」这里问题。使用构建器实例化复杂对象，就能很好的解决这个问题了。</p>
<h2 id="新理解"><a href="#新理解" class="headerlink" title="新理解"></a>新理解</h2><p>在前面的「区别」和「我的看法」中，我对建造者模式有点误解。现在，在观察其他代码的过程中，有了新的理解，新的发现。当时是觉得上面的代码写的不是建造者模式，而是构建器的使用。而现在我发现，构建器的使用正是使用了建造者模式。</p>
<p>在标准的建造者模式的UML图中， Builder 类是一个抽象的类，而 ConcreteBuilder 类则是它的具体实现类。而且还有 Director 指挥者类。而在上面的代码中， Builder 类却是一个静态内部类，而且还不是抽象类，也看不到它的子类，更看不到 Director 类。这就让我觉得它并非建造者模式，而是构建器的使用。可是后来我发现，在上面的代码中，在 TestBuilder 这个测试类中，我们不是实例化了 Builder 类吗？这不就相当于 ConcreteBuilder 的使用吗？而且， Director 类不是省去合并到 Builder 类中吗！原来如此！</p>


<!--<a href="http://yoursite.com/2017/04/02/建造者模式/#disqus_thread" class="article-comment-link">Comments</a>-->
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'undefined'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script>
</div>







</body>
</html>